#Пытался сделать автовычисление n в проге, но огромное количество ошибок компиляции заставило меня прекратить попытки искать оптимальное n

#Функция нахождения оптимального n:

def optimal_n(u_, i):
#TODO оценить остаточный член так, чтобы он был меньше точности

    check = ((sp.diff(u_, t) * t**(i+1)) / sp.factorial(i+1)) #остаточный член ряда Маклорена в форме Лагранжа
    if check(1) <= precision:
        return i, True
    else:
        return -1, False
        
#Модифицированная функция с optimal_n:

def mac_series(u): #u = func1 или func2

    u_ = sp.lambdify(t, u) #"готовая" func(t) для numpy.var
    sum = u_(0) #первый член разложения по маклорену
    i = 1

    while True:
        u = sp.diff(u, t)  # очищается из памяти прошлое значение u, теперь u указывает на производную du/dt
        u_ = sp.lambdify(t, u)  # аналогично
        sum = sum + ((u_(0) * (t ** i)) / sp.factorial(i))
        if optimal_n(u_, i)[2]:
            return sum, i
        i += 1
        if i >= STOP:
            break
